<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ImageBase</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImageBase</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ImageBase</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Spatial-transformation"><span>Spatial transformation</span></a></li><li><a class="tocitem" href="#Discrete-gradient-operator"><span>Discrete gradient operator</span></a></li><li><a class="tocitem" href="#Statistics"><span>Statistics</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/ImageBase.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="function_reference"><a class="docs-heading-anchor" href="#function_reference">Reference</a><a id="function_reference-1"></a><a class="docs-heading-anchor-permalink" href="#function_reference" title="Permalink"></a></h1><h2 id="Spatial-transformation"><a class="docs-heading-anchor" href="#Spatial-transformation">Spatial transformation</a><a id="Spatial-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-transformation" title="Permalink"></a></h2><ul><li><code>restrict</code> originally lives in <a href="https://github.com/JuliaImages/ImageTransformations.jl">ImageTransformation.jl</a>. This function is still reexported by ImageTransformation.</li></ul><article class="docstring"><header><a class="docstring-binding" id="ImageBase.restrict" href="#ImageBase.restrict"><code>ImageBase.restrict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">restrict(img[, dims]) -&gt; imgr</code></pre><p>Reduce the size of <code>img</code> by approximately two-fold along the dimensions listed in <code>dims</code>, or all spatial coordinates if <code>dims</code> is not specified.</p><p><strong>Output</strong></p><p>The type of output array <code>imgr</code> depends on the input type:</p><ul><li>If <code>img</code> is an <code>OffsetArray</code>, then output array <code>imgr</code> will also be an <code>OffsetArray</code>.</li><li>If <code>img</code> is not an <code>OffsetArray</code>, then output array <code>imgr</code> will be an <code>Array</code> type even if it has offset indices.</li></ul><p>The size of <code>imgr</code> is approximately <code>1/2</code> of the original size. More specifically:</p><ul><li>if <code>Nₖ = size(img, k)</code> is odd, then <code>size(imgr, k) == (Nₖ+1) ÷ 2</code>.</li><li>if <code>Nₖ = size(img, k)</code> is even, then <code>size(imgr, k) == (Nₖ÷2) + 1</code>.</li></ul><p><strong>Examples</strong></p><p>The optional argument <code>dims</code> can be a <code>Tuple</code> or <code>Integer</code>:</p><pre><code class="language-julia hljs">A = rand(5, 5) # size: (5, 5)

restrict(A) # size: (3, 3)

restrict(A, 1) # size: (3, 5)
restrict(A, 2) # size: (5, 3)

restrict(A, (1, )) # size: (3, 5)
restrict(A, (1, 2)) # size: (3, 3)</code></pre><p>Unless the input array is 1-based, the origin will be halfed:</p><pre><code class="language-julia hljs">julia&gt; using ImageBase, OffsetArrays

julia&gt; Ao = OffsetArray(rand(5, 4), 5, 6);

julia&gt; Ar = restrict(Ao);

julia&gt; axes(Ao)
(OffsetArrays.IdOffsetRange(values=6:10, indices=6:10), OffsetArrays.IdOffsetRange(values=7:10, indices=7:10))

julia&gt; axes(Ar)
(OffsetArrays.IdOffsetRange(values=3:5, indices=3:5), OffsetArrays.IdOffsetRange(values=4:6, indices=4:6))</code></pre><p><strong>Extended help</strong></p><p>The term <code>restrict</code> is taken from the coarsening operation of algebraic multigrid methods; it is the adjoint of &quot;prolongation&quot; (which is essentially interpolation). <code>restrict</code> anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks. The implementation of <code>restrict</code> has been tuned for performance, and should be a fast method for constructing <a href="https://en.wikipedia.org/wiki/Pyramid_(image_processing)">pyramids</a>.</p><p>If <code>l</code> is the size of <code>img</code> along a particular dimension, <code>restrict</code> produces an array of size <code>(l+1)÷2</code> for odd <code>l</code>, and <code>l÷2 + 1</code> for even <code>l</code>. See the example below for an explanation.</p><p>See also <code>ImageTransformations.imresize</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a_course = [0, 1, 0.3]</code></pre><p>If we were to interpolate this at the halfway points, we&#39;d get</p><pre><code class="language-julia hljs">a_fine = [0, 0.5, 1, 0.65, 0.3]</code></pre><p>Note that <code>a_fine</code> is obtained from <code>a_course</code> via the <em>prolongation</em> operator <code>P</code> as <code>P*a_course</code>, where</p><pre><code class="language-julia hljs">P = [1   0   0;      # this line &quot;copies over&quot; the first point
     0.5 0.5 0;      # this line takes the mean of the first and second point
     0   1   0;      # copy the second point
     0   0.5 0.5;    # take the mean of the second and third
     0   0   1]      # copy the third</code></pre><p><code>restrict</code> is the adjoint of prolongation. Consequently,</p><pre><code class="language-julia hljs">julia&gt; restrict(a_fine)
3-element Array{Float64,1}:
 0.125
 0.7875
 0.3125

julia&gt; (P&#39;*a_fine)/2
3-element Array{Float64,1}:
 0.125
 0.7875
 0.3125</code></pre><p>where the division by 2 approximately preserves the mean intensity of the input.</p><p>As we see here, for odd-length <code>a_fine</code>, restriction is the adjoint of interpolation at half-grid points. When <code>length(a_fine)</code> is even, restriction is the adjoint of interpolation at 1/4 and 3/4-grid points. This turns out to be the origin of the <code>l-&gt;l÷2 + 1</code> behavior.</p><p>One consequence of this definition is that the edges move towards zero:</p><pre><code class="language-julia hljs">julia&gt; restrict(ones(11))
6-element Array{Float64,1}:
 0.75
 1.0
 1.0
 1.0
 1.0
 0.75</code></pre><p>In some applications (e.g., image registration), you may find it useful to trim the edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/restrict.jl#L1-L117">source</a></section></article><h2 id="Discrete-gradient-operator"><a class="docs-heading-anchor" href="#Discrete-gradient-operator">Discrete gradient operator</a><a id="Discrete-gradient-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-gradient-operator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff" href="#ImageBase.FiniteDiff"><code>ImageBase.FiniteDiff</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Although stored as an array, image can also be viewed as a function from discrete grid space Zᴺ to continuous space R if it is gray image, to C if it is complex-valued image (MRI rawdata), to Rᴺ if it is colorant image, etc. This module provides the discrete version of gradient-related operators by viewing image arrays as functions.</p><p>This module provides:</p><ul><li>forward/backward difference <a href="#ImageBase.FiniteDiff.fdiff-Tuple{AbstractArray}"><code>fdiff</code></a> are the Images-flavor of <code>Base.diff</code></li><li>gradient operator <a href="#ImageBase.FiniteDiff.fgradient-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>fgradient</code></a> and its adjoint via keyword <code>adjoint=true</code>.</li><li>divergence operator <a href="#ImageBase.FiniteDiff.fdiv-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Vararg{AbstractArray{T, N} where N, N} where N}} where T"><code>fdiv</code></a> computes the sum of discrete derivatives of vector fields.</li><li>laplacian operator <a href="#ImageBase.FiniteDiff.flaplacian-Tuple{AbstractArray}"><code>flaplacian</code></a> is the divergence of the gradient fields.</li></ul><p>Every function in this module has its in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L8-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.fdiff!-Tuple{AbstractArray, AbstractArray}" href="#ImageBase.FiniteDiff.fdiff!-Tuple{AbstractArray, AbstractArray}"><code>ImageBase.FiniteDiff.fdiff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff!(dst::AbstractArray, src::AbstractArray; dims::Int, rev=false, boundary=:periodic)</code></pre><p>The in-place version of <a href="#ImageBase.FiniteDiff.fdiff-Tuple{AbstractArray}"><code>fdiff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.fdiff-Tuple{AbstractArray}" href="#ImageBase.FiniteDiff.fdiff-Tuple{AbstractArray}"><code>ImageBase.FiniteDiff.fdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff(A::AbstractArray; dims::Int, rev=false, boundary=:periodic)</code></pre><p>A one-dimension finite difference operator on array <code>A</code>. Unlike <code>Base.diff</code>, this function doesn&#39;t shrink the array size.</p><p>Take vector as an example, it computes <code>(A[2]-A[1], A[3]-A[2], ..., A[1]-A[end])</code>.</p><p><strong>Keywords</strong></p><ul><li><code>rev::Bool</code> If <code>rev==true</code>, then it computes the backward difference <code>(A[end]-A[1], A[1]-A[2], ..., A[end-1]-A[end])</code>.</li><li><code>boundary</code> By default it computes periodically in the boundary, i.e., <code>:periodic</code>. In some cases, one can fill zero values with <code>boundary=:zero</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [2 4 8; 3 9 27; 4 16 64]
3×3 Matrix{Int64}:
 2   4   8
 3   9  27
 4  16  64

julia&gt; diff(A, dims=2) # this function exists in Base
3×2 Matrix{Int64}:
  2   4
  6  18
 12  48

julia&gt; fdiff(A, dims=2)
3×3 Matrix{Int64}:
  2   4   -6
  6  18  -24
 12  48  -60

julia&gt; fdiff(A, dims=2, rev=true) # reverse diff
3×3 Matrix{Int64}:
  -6   2   4
 -24   6  18
 -60  12  48

julia&gt; fdiff(A, dims=2, boundary=:zero) # fill boundary with zeros
3×3 Matrix{Int64}:
  2   4  0
  6  18  0
 12  48  0</code></pre><p>See also <a href="#ImageBase.FiniteDiff.fdiff!-Tuple{AbstractArray, AbstractArray}"><code>fdiff!</code></a> for the in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L34-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.fdiv!-Tuple{AbstractArray, AbstractArray, Vararg{AbstractArray, N} where N}" href="#ImageBase.FiniteDiff.fdiv!-Tuple{AbstractArray, AbstractArray, Vararg{AbstractArray, N} where N}"><code>ImageBase.FiniteDiff.fdiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiv!(out, Vs...)</code></pre><p>The in-place version of divergence operator <a href="#ImageBase.FiniteDiff.fdiv-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Vararg{AbstractArray{T, N} where N, N} where N}} where T"><code>fdiv</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.fdiv-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Vararg{AbstractArray{T, N} where N, N} where N}} where T" href="#ImageBase.FiniteDiff.fdiv-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Vararg{AbstractArray{T, N} where N, N} where N}} where T"><code>ImageBase.FiniteDiff.fdiv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiv(Vs...)</code></pre><p>Compute the divergence of vector fields <code>Vs</code>.</p><p>See also <a href="#ImageBase.FiniteDiff.fdiv!-Tuple{AbstractArray, AbstractArray, Vararg{AbstractArray, N} where N}"><code>fdiv!</code></a> for the in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.fgradient!-Union{Tuple{N}, Tuple{Tuple{Vararg{var&quot;#s7&quot;, N}} where var&quot;#s7&quot;&lt;:AbstractArray, Any}} where N" href="#ImageBase.FiniteDiff.fgradient!-Union{Tuple{N}, Tuple{Tuple{Vararg{var&quot;#s7&quot;, N}} where var&quot;#s7&quot;&lt;:AbstractArray, Any}} where N"><code>ImageBase.FiniteDiff.fgradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fgradient!(∇X::Tuple, X::AbstractArray; adjoint=false, boundary=:periodic)</code></pre><p>The in-place version of (adjoint) gradient operator <a href="#ImageBase.FiniteDiff.fgradient-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>fgradient</code></a>.</p><p>The input <code>∇X = (∂₁X, ∂₂X, ..., ∂ₙX)</code> is a tuple of arrays that are similar to <code>X</code>, i.e., <code>eltype(∂ᵢX) == eltype(X)</code> and <code>axes(∂ᵢX)  == axes(X)</code> for all <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.fgradient-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#ImageBase.FiniteDiff.fgradient-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>ImageBase.FiniteDiff.fgradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fgradient(X::AbstractArray; adjoint=false, boundary=:periodic) -&gt; (∂₁X, ∂₂X, ..., ∂ₙX)</code></pre><p>Computes the gradient fields of <code>X</code>. If <code>adjoint==true</code> then it computes the adjoint gradient fields.</p><p>Each gradient vector is computed as forward difference along specific dimension, e.g., <a href="#ImageBase.FiniteDiff.fdiff-Tuple{AbstractArray}"><code>∂ᵢX = fdiff(X, dims=i)</code></a>. The <code>boundary</code> keyword is passed to <code>fdiff</code> to specify the behavior on boundary.</p><p>Mathematically, the adjoint operator ∂ᵢ&#39; of ∂ᵢ is defined as <code>&lt;∂ᵢu, v&gt; := &lt;u, ∂ᵢ&#39;v&gt;</code>, where <code>&lt;a, b&gt;</code> is the inner product of vector <code>a</code> and <code>b</code>.</p><p>See also the in-place version <a href="#ImageBase.FiniteDiff.fgradient!-Union{Tuple{N}, Tuple{Tuple{Vararg{var&quot;#s7&quot;, N}} where var&quot;#s7&quot;&lt;:AbstractArray, Any}} where N"><code>fgradient!(X)</code></a> to reuse the allocated memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L199-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.flaplacian!-Tuple{Any, AbstractArray}" href="#ImageBase.FiniteDiff.flaplacian!-Tuple{Any, AbstractArray}"><code>ImageBase.FiniteDiff.flaplacian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flaplacian!(out, X)
flaplacian!(out, ∇X::Tuple, X)</code></pre><p>The in-place version of the laplacian operator <a href="#ImageBase.FiniteDiff.flaplacian-Tuple{AbstractArray}"><code>flaplacian</code></a>.</p><p>!!! tip Avoiding allocations     The two-argument method will allocate memory to store the intermediate     gradient fields <code>∇X</code>. If you call this repeatedly with images of consistent size and type,     consider using the three-argument form with pre-allocated memory for <code>∇X</code>,     which will eliminate allocation by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L183-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.FiniteDiff.flaplacian-Tuple{AbstractArray}" href="#ImageBase.FiniteDiff.flaplacian-Tuple{AbstractArray}"><code>ImageBase.FiniteDiff.flaplacian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flaplacian(X::AbstractArray)</code></pre><p>The discrete laplacian operator, i.e., the divergence of the gradient fields of <code>X</code>.</p><p>See also <a href="#ImageBase.FiniteDiff.flaplacian!-Tuple{Any, AbstractArray}"><code>flaplacian!</code></a> for the in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/diff.jl#L174-L180">source</a></section></article><h2 id="Statistics"><a class="docs-heading-anchor" href="#Statistics">Statistics</a><a id="Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Statistics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageBase.minimum_finite" href="#ImageBase.minimum_finite"><code>ImageBase.minimum_finite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimum_finite([f=identity], A; kwargs...)</code></pre><p>Calculate <code>minimum(f, A)</code> while ignoring any values that are not finite, e.g., <code>Inf</code> or <code>NaN</code>.</p><p>If <code>A</code> is a colorant array with multiple channels (e.g., <code>Array{RGB}</code>), the <code>min</code> comparison is done in channel-wise sense.</p><p>The supported <code>kwargs</code> are those of <code>minimum(f, A; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/statistics.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.maximum_finite" href="#ImageBase.maximum_finite"><code>ImageBase.maximum_finite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maximum_finite([f=identity], A; kwargs...)</code></pre><p>Calculate <code>maximum(f, A)</code> while ignoring any values that are not finite, e.g., <code>Inf</code> or <code>NaN</code>.</p><p>If <code>A</code> is a colorant array with multiple channels (e.g., <code>Array{RGB}</code>), the <code>max</code> comparison is done in channel-wise sense.</p><p>The supported <code>kwargs</code> are those of <code>maximum(f, A; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/statistics.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.meanfinite" href="#ImageBase.meanfinite"><code>ImageBase.meanfinite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meanfinite([f=identity], A; kwargs...)</code></pre><p>Compute <code>mean(f, A)</code> while ignoring any non-finite values.</p><p>The supported <code>kwargs</code> are those of <code>sum(f, A; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/statistics.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.varfinite" href="#ImageBase.varfinite"><code>ImageBase.varfinite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">varfinite(A; kwargs...)</code></pre><p>Compute the variance of <code>A</code>, ignoring any non-finite values.</p><p>The supported <code>kwargs</code> are those of <code>sum(f, A; kwargs...)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function can produce a seemingly suprising result if the input array is an RGB image. To make it more clear, the implementation is made so that <code>varfinite(img) ≈ varfinite(RGB.(img))</code> holds for any gray-scale image. See also https://github.com/JuliaGraphics/ColorVectorSpace.jl#abs-and-abs2 for more information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/statistics.jl#L73-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBase.sumfinite" href="#ImageBase.sumfinite"><code>ImageBase.sumfinite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sumfinite([f=identity], A; kwargs...)</code></pre><p>Compute <code>sum(f, A)</code> while ignoring any non-finite values.</p><p>The supported <code>kwargs</code> are those of <code>sum(f, A; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageBase.jl/blob/b592c453f0a934eecbfa29418c8b7eee6ed86b04/src/statistics.jl#L35-L41">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« ImageBase</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 20 October 2021 15:42">Wednesday 20 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

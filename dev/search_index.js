var documenterSearchIndex = {"docs":
[{"location":"reference/#function_reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Spatial-transformation","page":"Reference","title":"Spatial transformation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"restrict originally lives in ImageTransformation.jl. This function is still reexported by ImageTransformation.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"restrict","category":"page"},{"location":"reference/#ImageBase.restrict","page":"Reference","title":"ImageBase.restrict","text":"restrict(img[, dims]) -> imgr\n\nReduce the size of img by approximately two-fold along the dimensions listed in dims, or all spatial coordinates if dims is not specified.\n\nOutput\n\nThe type of output array imgr depends on the input type:\n\nIf img is an OffsetArray, then output array imgr will also be an OffsetArray.\nIf img is not an OffsetArray, then output array imgr will be an Array type even if it has offset indices.\n\nThe size of imgr is approximately 1/2 of the original size. More specifically:\n\nif Nₖ = size(img, k) is odd, then size(imgr, k) == (Nₖ+1) ÷ 2.\nif Nₖ = size(img, k) is even, then size(imgr, k) == (Nₖ÷2) + 1.\n\nExamples\n\nThe optional argument dims can be a Tuple or Integer:\n\nA = rand(5, 5) # size: (5, 5)\n\nrestrict(A) # size: (3, 3)\n\nrestrict(A, 1) # size: (3, 5)\nrestrict(A, 2) # size: (5, 3)\n\nrestrict(A, (1, )) # size: (3, 5)\nrestrict(A, (1, 2)) # size: (3, 3)\n\nUnless the input array is 1-based, the origin will be halfed:\n\njulia> using ImageBase, OffsetArrays\n\njulia> Ao = OffsetArray(rand(5, 4), 5, 6);\n\njulia> Ar = restrict(Ao);\n\njulia> axes(Ao)\n(OffsetArrays.IdOffsetRange(values=6:10, indices=6:10), OffsetArrays.IdOffsetRange(values=7:10, indices=7:10))\n\njulia> axes(Ar)\n(OffsetArrays.IdOffsetRange(values=3:5, indices=3:5), OffsetArrays.IdOffsetRange(values=4:6, indices=4:6))\n\nExtended help\n\nThe term restrict is taken from the coarsening operation of algebraic multigrid methods; it is the adjoint of \"prolongation\" (which is essentially interpolation). restrict anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks. The implementation of restrict has been tuned for performance, and should be a fast method for constructing pyramids.\n\nIf l is the size of img along a particular dimension, restrict produces an array of size (l+1)÷2 for odd l, and l÷2 + 1 for even l. See the example below for an explanation.\n\nSee also ImageTransformations.imresize.\n\nExample\n\na_coarse = [0, 1, 0.3]\n\nIf we were to interpolate this at the halfway points, we'd get\n\na_fine = [0, 0.5, 1, 0.65, 0.3]\n\nNote that a_fine is obtained from a_coarse via the prolongation operator P as P*a_coarse, where\n\nP = [1   0   0;      # this line \"copies over\" the first point\n     0.5 0.5 0;      # this line takes the mean of the first and second point\n     0   1   0;      # copy the second point\n     0   0.5 0.5;    # take the mean of the second and third\n     0   0   1]      # copy the third\n\nrestrict is the adjoint of prolongation. Consequently,\n\njulia> restrict(a_fine)\n3-element Array{Float64,1}:\n 0.125\n 0.7875\n 0.3125\n\njulia> (P'*a_fine)/2\n3-element Array{Float64,1}:\n 0.125\n 0.7875\n 0.3125\n\nwhere the division by 2 approximately preserves the mean intensity of the input.\n\nAs we see here, for odd-length a_fine, restriction is the adjoint of interpolation at half-grid points. When length(a_fine) is even, restriction is the adjoint of interpolation at 1/4 and 3/4-grid points. This turns out to be the origin of the l->l÷2 + 1 behavior.\n\nOne consequence of this definition is that the edges move towards zero:\n\njulia> restrict(ones(11))\n6-element Array{Float64,1}:\n 0.75\n 1.0\n 1.0\n 1.0\n 1.0\n 0.75\n\nIn some applications (e.g., image registration), you may find it useful to trim the edges.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Discrete-gradient-operator","page":"Reference","title":"Discrete gradient operator","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ImageBase.FiniteDiff]\norder = [:module, :function]","category":"page"},{"location":"reference/#ImageBase.FiniteDiff","page":"Reference","title":"ImageBase.FiniteDiff","text":"Although stored as an array, image can also be viewed as a function from discrete grid space Zᴺ to continuous space R if it is gray image, to C if it is complex-valued image (MRI rawdata), to Rᴺ if it is colorant image, etc. This module provides the discrete version of gradient-related operators by viewing image arrays as functions.\n\nThis module provides:\n\nforward/backward difference fdiff are the Images-flavor of Base.diff\ngradient operator fgradient and its adjoint via keyword adjoint=true.\ndivergence operator fdiv computes the sum of discrete derivatives of vector fields.\nlaplacian operator flaplacian is the divergence of the gradient fields.\n\nEvery function in this module has its in-place version.\n\n\n\n\n\n","category":"module"},{"location":"reference/#ImageBase.FiniteDiff.fdiff!-Tuple{AbstractArray, AbstractArray}","page":"Reference","title":"ImageBase.FiniteDiff.fdiff!","text":"fdiff!(dst::AbstractArray, src::AbstractArray; dims::Int, rev=false, boundary=:periodic)\n\nThe in-place version of fdiff\n\n\n\n\n\n","category":"method"},{"location":"reference/#ImageBase.FiniteDiff.fdiff-Tuple{AbstractArray}","page":"Reference","title":"ImageBase.FiniteDiff.fdiff","text":"fdiff(A::AbstractArray; dims::Int, rev=false, boundary=:periodic)\n\nA one-dimension finite difference operator on array A. Unlike Base.diff, this function doesn't shrink the array size.\n\nTake vector as an example, it computes (A[2]-A[1], A[3]-A[2], ..., A[1]-A[end]).\n\nKeywords\n\nrev::Bool If rev==true, then it computes the backward difference (A[end]-A[1], A[1]-A[2], ..., A[end-1]-A[end]).\nboundary By default it computes periodically in the boundary, i.e., :periodic. In some cases, one can fill zero values with boundary=:zero.\n\nExamples\n\njulia> A = [2 4 8; 3 9 27; 4 16 64]\n3×3 Matrix{Int64}:\n 2   4   8\n 3   9  27\n 4  16  64\n\njulia> diff(A, dims=2) # this function exists in Base\n3×2 Matrix{Int64}:\n  2   4\n  6  18\n 12  48\n\njulia> fdiff(A, dims=2)\n3×3 Matrix{Int64}:\n  2   4   -6\n  6  18  -24\n 12  48  -60\n\njulia> fdiff(A, dims=2, rev=true) # reverse diff\n3×3 Matrix{Int64}:\n  -6   2   4\n -24   6  18\n -60  12  48\n\njulia> fdiff(A, dims=2, boundary=:zero) # fill boundary with zeros\n3×3 Matrix{Int64}:\n  2   4  0\n  6  18  0\n 12  48  0\n\nSee also fdiff! for the in-place version.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ImageBase.FiniteDiff.fdiv!-Tuple{AbstractArray, AbstractArray, Vararg{AbstractArray}}","page":"Reference","title":"ImageBase.FiniteDiff.fdiv!","text":"fdiv!(out, Vs...)\n\nThe in-place version of divergence operator fdiv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ImageBase.FiniteDiff.fdiv-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{AbstractArray{T}}}} where T","page":"Reference","title":"ImageBase.FiniteDiff.fdiv","text":"fdiv(Vs...)\n\nCompute the divergence of vector fields Vs.\n\nSee also fdiv! for the in-place version.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ImageBase.FiniteDiff.fgradient!-Union{Tuple{N}, Tuple{Tuple{Vararg{var\"#s7\", N}} where var\"#s7\"<:AbstractArray, Any}} where N","page":"Reference","title":"ImageBase.FiniteDiff.fgradient!","text":"fgradient!(∇X::Tuple, X::AbstractArray; adjoint=false, boundary=:periodic)\n\nThe in-place version of (adjoint) gradient operator fgradient.\n\nThe input ∇X = (∂₁X, ∂₂X, ..., ∂ₙX) is a tuple of arrays that are similar to X, i.e., eltype(∂ᵢX) == eltype(X) and axes(∂ᵢX)  == axes(X) for all i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ImageBase.FiniteDiff.fgradient-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Reference","title":"ImageBase.FiniteDiff.fgradient","text":"fgradient(X::AbstractArray; adjoint=false, boundary=:periodic) -> (∂₁X, ∂₂X, ..., ∂ₙX)\n\nComputes the gradient fields of X. If adjoint==true then it computes the adjoint gradient fields.\n\nEach gradient vector is computed as forward difference along specific dimension, e.g., ∂ᵢX = fdiff(X, dims=i). The boundary keyword is passed to fdiff to specify the behavior on boundary.\n\nMathematically, the adjoint operator ∂ᵢ' of ∂ᵢ is defined as <∂ᵢu, v> := <u, ∂ᵢ'v>, where <a, b> is the inner product of vector a and b.\n\nSee also the in-place version fgradient!(X) to reuse the allocated memory.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ImageBase.FiniteDiff.flaplacian!-Tuple{Any, AbstractArray}","page":"Reference","title":"ImageBase.FiniteDiff.flaplacian!","text":"flaplacian!(out, X)\nflaplacian!(out, ∇X::Tuple, X)\n\nThe in-place version of the laplacian operator flaplacian.\n\n!!! tip Avoiding allocations     The two-argument method will allocate memory to store the intermediate     gradient fields ∇X. If you call this repeatedly with images of consistent size and type,     consider using the three-argument form with pre-allocated memory for ∇X,     which will eliminate allocation by this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ImageBase.FiniteDiff.flaplacian-Tuple{AbstractArray}","page":"Reference","title":"ImageBase.FiniteDiff.flaplacian","text":"flaplacian(X::AbstractArray)\n\nThe discrete laplacian operator, i.e., the divergence of the gradient fields of X.\n\nSee also flaplacian! for the in-place version.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Statistics","page":"Reference","title":"Statistics","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"minimum_finite\nmaximum_finite\nmeanfinite\nvarfinite\nsumfinite","category":"page"},{"location":"reference/#ImageBase.minimum_finite","page":"Reference","title":"ImageBase.minimum_finite","text":"minimum_finite([f=identity], A; kwargs...)\n\nCalculate minimum(f, A) while ignoring any values that are not finite, e.g., Inf or NaN.\n\nIf A is a colorant array with multiple channels (e.g., Array{RGB}), the min comparison is done in channel-wise sense.\n\nThe supported kwargs are those of minimum(f, A; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageBase.maximum_finite","page":"Reference","title":"ImageBase.maximum_finite","text":"maximum_finite([f=identity], A; kwargs...)\n\nCalculate maximum(f, A) while ignoring any values that are not finite, e.g., Inf or NaN.\n\nIf A is a colorant array with multiple channels (e.g., Array{RGB}), the max comparison is done in channel-wise sense.\n\nThe supported kwargs are those of maximum(f, A; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageBase.meanfinite","page":"Reference","title":"ImageBase.meanfinite","text":"meanfinite([f=identity], A; kwargs...)\n\nCompute mean(f, A) while ignoring any non-finite values.\n\nThe supported kwargs are those of sum(f, A; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageBase.varfinite","page":"Reference","title":"ImageBase.varfinite","text":"varfinite(A; kwargs...)\n\nCompute the variance of A, ignoring any non-finite values.\n\nThe supported kwargs are those of sum(f, A; kwargs...).\n\nnote: Note\nThis function can produce a seemingly suprising result if the input array is an RGB image. To make it more clear, the implementation is made so that varfinite(img) ≈ varfinite(RGB.(img)) holds for any gray-scale image. See also https://github.com/JuliaGraphics/ColorVectorSpace.jl#abs-and-abs2 for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageBase.sumfinite","page":"Reference","title":"ImageBase.sumfinite","text":"sumfinite([f=identity], A; kwargs...)\n\nCompute sum(f, A) while ignoring any non-finite values.\n\nThe supported kwargs are those of sum(f, A; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"#ImageBase","page":"ImageBase","title":"ImageBase","text":"","category":"section"},{"location":"","page":"ImageBase","title":"ImageBase","text":"This is a twin package to ImageCore with functions that are used among many of the packages in JuliaImages. The main purpose of this package is to reduce unnecessary compilation overhead from external dependencies.","category":"page"},{"location":"","page":"ImageBase","title":"ImageBase","text":"This package reexports ImageCore so can be a direct replacement of it.","category":"page"},{"location":"","page":"ImageBase","title":"ImageBase","text":"Check the reference page for more information.","category":"page"}]
}
